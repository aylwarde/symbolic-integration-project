#include "polynomials.h"

/*half, full extended euclidean algorithm, regular and diophantine version*/

poly **half_extended_euclidean();
poly **extended_euclidean();
poly *half_extended_euclidean_diophantine();
poly **extended_euclidean_diophantine();

//return a_1 such that a_1*poly1 = a, and return a=gcd(poly1, poly2)
poly **half_extended_euclidean(poly *poly1, poly *poly2) {

	poly *q, *r, *a_1, *b_1, *r_1;
	poly **result;
	mpz_t one; mpz_init_set_si(one,1);

	a_1 = initialize_p(0);
       	a_1->coefficients[0] = init_f(one,one);	
	b_1 = initialize_p(0); 

	while(!zero_p(poly2))
	{
		q = divide_p(poly1, poly2)[0];
		r = divide_p(poly1, poly2)[1];

		poly1 = copy_p(poly2);
		poly2 = copy_p(r);
		
		r_1 = subtract_p(a_1, multiply_p(q, b_1));
		a_1 = copy_p(b_1);
		b_1 = copy_p(r_1);
	}

	result = initialize_array_p(2);
	result[0] = a_1;
	result[1] = poly1;

	return result;
}

//returns s,t,g such that g=gcd(poly1,poly2) and s*poly1+t*poly2 = g
poly **extended_euclidean(poly *poly1, poly *poly2) {

	poly *s, *g, *t, *r;
	poly **result;

	s = half_extended_euclidean(poly1, poly2)[0];
	g = half_extended_euclidean(poly1, poly2)[1];
	t = divide_p(subtract_p(g, multiply_p(s, poly1)), poly2)[0]; 
	r = divide_p(subtract_p(g, multiply_p(s, poly1)), poly2)[1]; //r must be zero

	result = initialize_array_p(3);
	result[0] = s;
	result[1] = t;
	result[2] = g;	

	return result;
}

poly *half_extended_euclidean_diophantine(poly *a, poly *b, poly *c) {
	
	poly *s, *g, *q, *r;

	s = half_extended_euclidean(a,b)[0];
	g = half_extended_euclidean(a,b)[1];

	q = divide_p(c,g)[0];
	r = divide_p(c,g)[1];

	if(!zero_p(r))
	{
		exit(0); // c is not in the ideal generated by a and b
	}
	
	s = multiply_p(q,s);

	if(!zero_p(s) && s->deg>=b->deg)
	{
		q = divide_p(s,b)[0];
		r = divide_p(s,b)[1];
		s = r;
	}

	return s;
}

poly **extended_euclidean_diophantine(poly *a, poly *b, poly *c) {

	poly *s, *t, *r;
	poly **result;

	s = half_extended_euclidean_diophantine(a,b,c);
	t = divide_p(subtract_p(c, multiply_p(s,a)), b)[0];
	r = divide_p(subtract_p(c, multiply_p(s,a)), b)[1];

	result = initialize_array_p(2);
	result[0] = s;
	result[1] = t;

	return result;
}


