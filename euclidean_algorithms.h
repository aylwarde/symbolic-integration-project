#ifndef EUCLIDEAN_ALGORITHMS_H
#define EUCLIDEAN_ALGORITHMS_H

#include "polynomials.h"

/*half, full extended euclidean algorithm, regular and diophantine version*/

poly **half_extended_euclidean();
poly **extended_euclidean();
poly *half_extended_euclidean_diophantine();
poly **extended_euclidean_diophantine();

//return a_1 such that a_1*poly1 = a, and return a=gcd(poly1, poly2)
poly **half_extended_euclidean(poly *poly1, poly *poly2) {

  poly *a_1, *b_1, *r_1;
  poly **result;
  poly **div;
  mpz_t one; mpz_init_set_si(one,1);

  a_1 = initialize_p(0);
  a_1->coefficients[0] = init_f(one,one);	
  b_1 = initialize_and_zero_p(0); 

  while(!zero_p(poly2))
    {
      div = divide_p(poly1, poly2);

      poly1 = copy_p(poly2);
      poly2 = copy_p(div[1]);
		
      r_1 = subtract_p(a_1, multiply_p(div[0], b_1));

      free_p(a_1);
      a_1 = copy_p(b_1);

      free_p(b_1);
      b_1 = copy_p(r_1);
      free_p(r_1);
      free_array_p(div, 2);
    }

  result = initialize_array_p(2);
  result[0] = scale_p(reciprocal_f(content_p(poly1)), a_1);
  result[1] = scale_p(reciprocal_f(content_p(poly1)), poly1);

  mpz_clear(one);
	
  free_p(b_1);
  free_p(a_1);

  return result;
}

//returns s,t,g such that g=gcd(poly1,poly2) and s*poly1+t*poly2 = g
poly **extended_euclidean(poly *poly1, poly *poly2) {

	poly **result;
	poly **half, **div;

	half = half_extended_euclidean(poly1, poly2);
	div = divide_p(subtract_p(half[1], multiply_p(half[0], poly1)), poly2); 
	//div[1] must be zero

	result = initialize_array_p(3);
	result[0] = copy_p(half[0]);
	result[1] = copy_p(div[0]);
	result[2] = copy_p(half[1]);	

	free_array_p(div, 2);
	free_array_p(half, 2);

	return result;
}

poly *half_extended_euclidean_diophantine(poly *a, poly *b, poly *c) {
	
	poly *s;
	poly **half, **div;

	half = half_extended_euclidean(a,b);
	div = divide_p(c, half[1]);

	if(!zero_p(div[1]))
	{
		exit(0); // c is not in the ideal generated by a and b
	}
	
	half[0] = multiply_p(div[0] ,half[0]);
	free_array_p(div, 2);

	if(!zero_p(half[0]) && half[0]->deg >= b->deg)
	{
		div = divide_p(half[0], b);
		free_p(half[0]);
		half[0] = copy_p(div[1]);
		free_array_p(div, 2);
	}

	s = copy_p(half[0]);
	free_array_p(half, 2);
	return s;
}

poly **extended_euclidean_diophantine(poly *a, poly *b, poly *c) {

	poly *s, **div;
	poly **result;

	s = half_extended_euclidean_diophantine(a,b,c);
	div = divide_p(subtract_p(c, multiply_p(s,a)), b); //div 1 must be zero

	result = initialize_array_p(2);
	result[0] = s;
	result[1] = copy_p(div[0]);
	free_array_p(div, 2);

	return result;
}

#endif /* EUCLIDEAN_ALGORITHMS_H */
